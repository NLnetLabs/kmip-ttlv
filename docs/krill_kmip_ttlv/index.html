<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A crate to de/serialize Rust data types from/to bytes in the KMIP TTLV format."><meta name="keywords" content="rust, rustlang, rust-lang, krill_kmip_ttlv"><title>krill_kmip_ttlv - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../krill_kmip_ttlv/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate krill_kmip_ttlv</h2><div class="block version"><p>Version 0.1.0-dev</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all krill_kmip_ttlv's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li></ul></div><div id="sidebar-vars" data-name="krill_kmip_ttlv" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">krill_kmip_ttlv</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/krill_kmip_ttlv/lib.rs.html#1-216" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A crate to de/serialize Rust data types from/to bytes in the KMIP TTLV format.</p>
<h1 id="serde" class="section-header"><a href="#serde">Serde</a></h1>
<p>This crate implements the <a href="https://docs.oasis-open.org/kmip/spec/v1.0/os/kmip-spec-1.0-os.html#_Toc262581260">KMIP TTLV data format</a> using <a href="https://serde.rs/">Serde</a>,<em>“a framework for <strong>ser</strong>ializing and
<strong>de</strong>serializing Rust data structures efficiently and generically”</em> and further assumes that you are using code
generated by <a href="https://serde.rs/derive.html">Serde Derive</a> to interface with the (de)serializer. Invoking the (de)serializer manually is not
advised.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
krill-kmip-ttlv = &quot;0.1.0&quot;
serde = &quot;1.0.126&quot;
serde_derive = &quot;1.0.126&quot;
</code></pre>
<p>Assuming that you have already defined your Rust types with the required Serde Derive attributes (more on this
below) you can serialize and deserialize them as follows:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">use</span> <span class="ident">krill_kmip_ttlv</span>::{<span class="ident">Config</span>, <span class="ident">from_slice</span>, <span class="ident">to_vec</span>};

<span class="comment">// Serialize some struct variable (whose type is correctly</span>
<span class="comment">// attributed) to bytes in TTLV format:</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="ident">to_vec</span>(<span class="kw-2">&amp;</span><span class="ident">my_struct</span>)<span class="question-mark">?</span>;

<span class="comment">// Deserialize the byte vec back to a struct:</span>
<span class="kw">let</span> <span class="ident">my_other_struct</span>: <span class="ident">MyStruct</span> <span class="op">=</span> <span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">bytes</span>)<span class="question-mark">?</span>;</pre></div>
<p>Note that this crate does <strong>NOT</strong> send or receive data, it only (de)serializes it.</p>
<h1 id="ttlv-format" class="section-header"><a href="#ttlv-format">TTLV format</a></h1>
<p>TTLV stands for Tag-Type-Length-Value which represents the format of each node in a tree when serialized to bytes:</p>
<ul>
<li>The TTLV format is defined as part of the <a href="https://docs.oasis-open.org/kmip/spec/v1.0/os/kmip-spec-1.0-os.html">Oasis Key Management Interoperability Protocol Specification Version
1.0</a> (aka KMIP) in <a href="https://docs.oasis-open.org/kmip/spec/v1.0/os/kmip-spec-1.0-os.html#_Toc262581260">Section 9.1 TTLV Encoding</a>.</li>
<li>The byte representation of a TTLV item consists of a 3 byte tag, a 1 byte type, a 4 byte length followed by zero
or more “Value” bytes.</li>
<li>Leaf nodes in the tree are TTLV items whose “Type” denotes them to be a primitive value of some kind (e.g. 
Integer, Boolean, etc) and whose “Value” is a single primitive value in serialized form, followed by any
required padding bytes.</li>
<li>All other tree nodes are “Structure” TTLV items whose value consists of zero or more TTLV items.</li>
</ul>
<p>Think of a TTLV “Structure” item as a Rust struct and all other TTLV items as fields within that struct but, unlike
Rust data types which have a string name, TTLV items are identified by a numeric “Tag”.</p>
<h1 id="mapping-names-to-tags" class="section-header"><a href="#mapping-names-to-tags">Mapping names to tags</a></h1>
<p>Rust identifies structs and struct fields by name but TTLV identifies items by numeric “Tag”. We must therefore 
provide a way to map from name to tag and vice versa. As this crate is Serde (Derive) based we can take advantage of
the [Serde Derive atribute] <code>#[serde(rename = &quot;...&quot;)]</code> to handle this for us:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">serde_derive::Serialize</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>)]</span>
<span class="attribute">#[<span class="ident">serde</span>(<span class="ident">rename</span> <span class="op">=</span> <span class="string">&quot;0x123456&quot;</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyTtlv</span> { }

<span class="macro">println!</span>(<span class="string">&quot;{:0X?}&quot;</span>, <span class="ident">krill_kmip_ttlv::to_vec</span>(<span class="kw-2">&amp;</span><span class="ident">MyTtlv</span> {}));

<span class="comment">// prints:</span>
<span class="comment">// Ok([12, 34, 56, 1, 0, 0, 0, 0])</span></pre></div>
<p>You can see the TTLV byte format here: a 3 byte “tag”, a 1 byte “type” (type code 1 means a TTLV Structure) and
a 4 byte “length”. There is no “value” part in this case because the struct doesn’t have any fields so the value
length is zero.</p>
<blockquote>
<p><strong>NOTE:</strong> If we omit the <code>#[serde(rename = &quot;...&quot;)]</code> attribute this code will print an error.</p>
</blockquote>
<h1 id="choosing-tag-values" class="section-header"><a href="#choosing-tag-values">Choosing tag values</a></h1>
<p>When implementing one of the KMIP specifications the tag value to use for each KMIP object is defined by the spec.
The KMIP specifications reserve tag value range 0x420000 - 0x42FFFF for official KMIP tags and reserve tag value
range 0x540000 - 0x54FFFF for custom extensions. If using TTLV as a serialization format for your own data you are
free to choose your own tag values anywhere in the range 0x000000 - 0xFFFFFF.</p>
<h1 id="unsupported-data-types" class="section-header"><a href="#unsupported-data-types">Unsupported data types</a></h1>
<p>Not all Rust and TTLV data types are supported by this crate, either because there is no obvious mapping from one to
the other or because support for it wasn’t needed yet:</p>
<ul>
<li>
<p>The following Rust types <strong>CANNOT</strong> be <em>serialized</em> to TTLV as TTLV has no concept of unsigned
integers, floating point, character or ‘missing’ values : <code>u8</code>, <code>u16</code>, <code>f32</code>, <code>f64</code>, <code>char</code>, <code>()</code>, <code>None</code> <em>(but see
below for a special note about <code>None</code>)</em>.</p>
</li>
<li>
<p>The following Rust types <strong>CANNOT</strong> be <em>deserialized</em> from TTLV: <code>()</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>,
<code>i8</code>, <code>i16</code>, <code>f32</code>, <code>f64</code>, <code>char</code>, <code>str</code>, map, <code>&amp;[u8]</code>, <code>()</code>.
<code>char</code>,</p>
</li>
<li>
<p>The following TTLV types <strong>CANNOT</strong> <em>yet</em> be (de)serialized: Big Integer (0x04), Interval (0x0A).</p>
</li>
<li>
<p>The following Rust types <strong>CANNOT</strong> be deserialized as this crate is opinionated and prefers to
deserialize only into named fields, not nameless groups of values: unit struct, tuple struct, tuple.</p>
</li>
</ul>
<h1 id="getting-involved" class="section-header"><a href="#getting-involved">Getting involved</a></h1>
<p>The capabilities of this crate and the TTLV and Rust data types supported are those that were needed to provide a
foundation for the <code>krill-kmip-protocol</code> crate. This crate does not yet support every possible TTLV or Rust type. If
you wish to extend the crate yourself PRs are welcome!</p>
<h1 id="data-types-treated-specially" class="section-header"><a href="#data-types-treated-specially">Data types treated specially</a></h1>
<ul>
<li>
<p>The Rust <code>struct</code> type by default serializes to a TTLV Structure However sometimes it is useful to be able to use a newtype struct as a wrapper around a primitive type so that you
can associate a TTLV tag value with it. This can be done by using the <code>Transparent:</code> prefix when renaming the
type, e.g. <code>#[serde(rename = &quot;Transparent:0xNNNNNN&quot;)]</code>.</p>
</li>
<li>
<p>The Rust <code>Some</code> type is handled as if it were only the value inside the Option, the <code>Some</code> wrapper is ignored.</p>
</li>
<li>
<p>The Rust <code>None</code> type cannot be serialized to TTLV. Instead use <code>#[serde(skip_serializing_if = &quot;Option::is_none&quot;)]</code>
on the <code>Option</code> field to be serialized so that Serde skips it if it has value <code>None</code> when serializing. When
deserializing into an <code>Option</code> if no value with the specified tag is present in the TTLV bytes the Option will be
set to <code>None</code>.</p>
</li>
<li>
<p>The Rust <code>Vec</code> type can be used to (de)serialize sequences of TTLV items. To serialize a <code>Vec</code> of bytes to a TTLV
Byte String however you should annotate the field with the Serde derive attribute <code>#[serde(with = &quot;serde_bytes&quot;)]</code>.</p>
</li>
<li>
<p>The Rust <code>enum</code> type is serialized differently depending on the type of the variant being serialized. For unit
variants a <code>#[serde(rename = &quot;0xNNNNNNNN&quot;)]</code> attribute should be used to cause this crate to serialize the value
as a TTLV Enumeration. A tuple or struct variant will be serialized to a TTLV Structure.</p>
</li>
<li>
<p>In order to <em>deserialize</em> into a Rust <code>enum</code> you must guide this crate to the correct variant to deserialize into.
To support the KMIP specifications this crate supports choosing the variant based on the value of a TTLV item that
was encountered earlier in the deserialization process. To handle this case each candidate <code>enum</code> variant must be
specially renamed with Serde derive using one of several supported special syntaxes:</p>
<ul>
<li><code>#[serde(rename = &quot;if 0xNNNNNN==0xMMMMMMMM&quot;)]</code> syntax will cause this crate to look for a previously encountered
TTLV Enumeration with tag value 0xNNNNNN and to select this <code>enum</code> variant if that Enumeration had value
0xMMMMMMMM.</li>
<li><code>#[serde(rename = &quot;if 0xNNNNNN in [0xAAAAAAAA, 0xBBBBBBBB, ..]&quot;)]</code> is like the previous syntax but can match
against more than one possible value.</li>
<li><code>#[serde(rename = &quot;if 0xNNNNNN &gt;= 0xMMMMMMMM&quot;)]</code> can be used to select the variant if a previously seen value
for the specified tag was at least the given value.</li>
<li><code>#[serde(rename = &quot;if 0xNNNNNN==Textual Content&quot;)]</code> syntax will cause this crate to look for a previously
encountered TTLV Text String with tag value 0xNNNNNN and to select this <code>enum</code> variant if that Text String had
value <code>Textual Content</code>.</li>
<li><code>#[serde(rename = &quot;if type==XXX&quot;)]</code> syntax (where <code>XXX</code> is a camel case TTLV type name without spaces such as
<code>LongInteger</code>) will cause this crate to select the enum variant if the TTLV type encountered while deserializing
has the specified type.</li>
</ul>
</li>
</ul>
<h1 id="supported-data-types" class="section-header"><a href="#supported-data-types">Supported data types</a></h1>
<p>The following gives a rough indication of the mapping of TTLV types to Rust types by this crate and vice versa:</p>
<table><thead><tr><th>TTLV data type</th><th>Serializes from</th><th>Deserializes to</th></tr></thead><tbody>
<tr><td>Structure (0x01)</td><td><code>SomeStruct { .. }</code>, <code>SomeStruct( .. )</code>, tuple variant</td><td><code>SomeStruct { .. }</code></td></tr>
<tr><td>Integer (0x02)</td><td><code>i8</code>, <code>i16</code>, <code>i32</code></td><td><code>i32</code></td></tr>
<tr><td>Long Integer (0x03)</td><td><code>i64</code></td><td><code>i64</code></td></tr>
<tr><td>Big Integer (0x04)</td><td><strong>UNSUPPORTED</strong></td><td><strong>UNSUPPORTED</strong></td></tr>
<tr><td>Enumeration (0x05)</td><td><code>u32</code></td><td>See above</td></tr>
<tr><td>Boolean (0x06)</td><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td>Text String (0x07)</td><td>`str``</td><td><code>String</code></td></tr>
<tr><td>Byte String (0x08)</td><td><code>&amp;[u8]</code></td><td><code>Vec&lt;u8&gt;</code></td></tr>
<tr><td>Date Time (0x09)</td><td><code>u64</code></td><td><code>i64</code></td></tr>
<tr><td>Interval (0x0A)</td><td><strong>UNSUPPORTED</strong></td><td><strong>UNSUPPORTED</strong></td></tr>
</tbody></table>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>For detailed examples of how to annotate your data types with Serde derive attributes for use with this crate look
at the tests in the source repository for this crate at the end of the <code>de.rs</code> and <code>ser.rs</code> source code files.</p>
<p>For much richer examples see the code and tests in the source repository for the <code>kmip-ttlv-protocol</code> crate.</p>
<h1 id="diagnostics" class="section-header"><a href="#diagnostics">Diagnostics</a></h1>
<p>If your crate provides a <a href="http://crates.io/crates/log">log</a> implementation then this crate will log at debug and trace level, if those levels
are enabled.</p>
<p>At debug level every byte array is dumped in hex form pre-deserialization and post-serialization, along with a human
readable tree of the TTLV tree it represents. The tree rendering is best effort in the case of invalid TTLV data.
At Trace level far too much detail about the internal logic of this crate is currently logged and will likely be
reduced as this crate matures.</p>
<h1 id="error-handling" class="section-header"><a href="#error-handling">Error handling</a></h1>
<p>Deserialization will be aborted by Serde if your type specification is too inflexible to handle the bytes being
deserialized. Thus, as with any Serde based deserializer, you may need to explicitly account for “known unknowns”,
i.e. in the case of KMIP, vendors are permitted to extend the response TTLV arbitrarily at certain points which can
be “ignored” by guiding Serde to deserialize the unknown bytes as just that: bytes.</p>
<p>This crate does not try to be clone free or to support <code>no_std</code> scenarios. Memory is allocated to serialize and
deserialize into. In particular when deserializing bytes received from an untrusted source with <code>from_reader()</code> this
could cause allocation of a large amount of memory at which point Rust will panic if the allocation fails. When
deserializing with <code>from_reader()</code> you are strongly advised to use a <code>Config</code> object that specifies a maximum byte
length to deserialize to prevent such abuse.</p>
<p>If serialization or deserialization fails this crate tries to return sufficient contextual information to aid
diagnosing where the problem in the TTLV byte stream is and why. Error reporting is a work in-progress and should
get better as the crate matures.</p>
</div></details><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr class="import-item"><td><code>pub use de::<a class="fn" href="de/fn.from_reader.html" title="fn krill_kmip_ttlv::de::from_reader">from_reader</a>;</code></td><td class="docblock-short"></td></tr><tr class="import-item"><td><code>pub use de::<a class="fn" href="de/fn.from_slice.html" title="fn krill_kmip_ttlv::de::from_slice">from_slice</a>;</code></td><td class="docblock-short"></td></tr><tr class="import-item"><td><code>pub use de::<a class="struct" href="de/struct.Config.html" title="struct krill_kmip_ttlv::de::Config">Config</a>;</code></td><td class="docblock-short"></td></tr><tr class="import-item"><td><code>pub use ser::<a class="fn" href="ser/fn.to_vec.html" title="fn krill_kmip_ttlv::ser::to_vec">to_vec</a>;</code></td><td class="docblock-short"></td></tr><tr class="import-item"><td><code>pub use ser::<a class="fn" href="ser/fn.to_writer.html" title="fn krill_kmip_ttlv::ser::to_writer">to_writer</a>;</code></td><td class="docblock-short"></td></tr></table><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="de/index.html" title="krill_kmip_ttlv::de mod">de</a></td><td class="docblock-short"><p>Deserialize TTLV bytes into Rust data types.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="error/index.html" title="krill_kmip_ttlv::error mod">error</a></td><td class="docblock-short"><p>When serializing or deserializing TTLV data goes wrong.</p>
</td></tr><tr class="module-item"><td><a class="mod" href="ser/index.html" title="krill_kmip_ttlv::ser mod">ser</a></td><td class="docblock-short"><p>Serialize a Rust data structure into TTLV data.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="krill_kmip_ttlv" data-search-index-js="../search-index.js" data-search-js="../search.js"></div><script src="../main.js"></script></body></html>